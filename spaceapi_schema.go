// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package main

import "encoding/json"
import "fmt"
import "reflect"

// SpaceAPI v15
type A15Json struct {
	// The versions your SpaceAPI endpoint supports
	ApiCompatibility []string `json:"api_compatibility" yaml:"api_compatibility" mapstructure:"api_compatibility"`

	// URL(s) of webcams in your space
	Cam []string `json:"cam,omitempty" yaml:"cam,omitempty" mapstructure:"cam,omitempty"`

	// Contact information about your space
	Contact A15JsonContact `json:"contact" yaml:"contact" mapstructure:"contact"`

	// Events which happened recently in your space and which could be interesting to
	// the public, like 'User X has entered/triggered/did something at timestamp Z'
	Events []A15JsonEventsElem `json:"events,omitempty" yaml:"events,omitempty" mapstructure:"events,omitempty"`

	// Feeds where users can get updates of your space
	Feeds *A15JsonFeeds `json:"feeds,omitempty" yaml:"feeds,omitempty" mapstructure:"feeds,omitempty"`

	// A list of spaces you know and feel connected too.
	LinkedSpaces []interface{} `json:"linked_spaces,omitempty" yaml:"linked_spaces,omitempty" mapstructure:"linked_spaces,omitempty"`

	// Arbitrary links that you'd like to share
	Links []A15JsonLinksElem `json:"links,omitempty" yaml:"links,omitempty" mapstructure:"links,omitempty"`

	// Position data such as a postal address or geographic coordinates. May be
	// omitted for spaces without a fixed physical location.
	Location *A15JsonLocation `json:"location,omitempty" yaml:"location,omitempty" mapstructure:"location,omitempty"`

	// URL to your space logo
	Logo string `json:"logo" yaml:"logo" mapstructure:"logo"`

	// A list of the different membership plans your hackerspace might have. Set the
	// value according to your billing process. For example, if your membership fee is
	// 10€ per month, but you bill it yearly (aka. the member pays the fee once per
	// year), set the amount to 120 an the billing_interval to yearly.
	MembershipPlans []A15JsonMembershipPlansElem `json:"membership_plans,omitempty" yaml:"membership_plans,omitempty" mapstructure:"membership_plans,omitempty"`

	// Your project sites (links to GitHub, wikis or wherever your projects are
	// hosted)
	Projects []string `json:"projects,omitempty" yaml:"projects,omitempty" mapstructure:"projects,omitempty"`

	// Data of various sensors in your space (e.g. temperature, humidity, amount of
	// Club-Mate left, …). The only canonical property is the <em>temp</em> property,
	// additional sensor types may be defined by you. In this case, you are requested
	// to share your definition for inclusion in this specification.
	Sensors *A15JsonSensors `json:"sensors,omitempty" yaml:"sensors,omitempty" mapstructure:"sensors,omitempty"`

	// The name of your space
	Space string `json:"space" yaml:"space" mapstructure:"space"`

	// A flag indicating if the hackerspace uses SpaceFED, a federated login scheme so
	// that visiting hackers can use the space WiFi with their home space credentials.
	Spacefed *A15JsonSpacefed `json:"spacefed,omitempty" yaml:"spacefed,omitempty" mapstructure:"spacefed,omitempty"`

	// A collection of status-related data: actual open/closed status, icons, last
	// change timestamp etc.
	State *A15JsonState `json:"state,omitempty" yaml:"state,omitempty" mapstructure:"state,omitempty"`

	// URL to your space website
	Url string `json:"url" yaml:"url" mapstructure:"url"`
}

// Contact information about your space
type A15JsonContact struct {
	// E-mail address for contacting your space. If this is a mailing list consider to
	// use the contact/ml field.
	Email *string `json:"email,omitempty" yaml:"email,omitempty" mapstructure:"email,omitempty"`

	// Facebook account URL.
	Facebook *string `json:"facebook,omitempty" yaml:"facebook,omitempty" mapstructure:"facebook,omitempty"`

	// Foursquare ID, in the form <samp>4d8a9114d85f3704eab301dc</samp>.
	Foursquare *string `json:"foursquare,omitempty" yaml:"foursquare,omitempty" mapstructure:"foursquare,omitempty"`

	// A URL to find information about the Space in the Gopherspace
	Gopher *string `json:"gopher,omitempty" yaml:"gopher,omitempty" mapstructure:"gopher,omitempty"`

	// Identi.ca or StatusNet account, in the form <samp>yourspace@example.org</samp>
	Identica *string `json:"identica,omitempty" yaml:"identica,omitempty" mapstructure:"identica,omitempty"`

	// URL of the IRC channel
	Irc *string `json:"irc,omitempty" yaml:"irc,omitempty" mapstructure:"irc,omitempty"`

	// A separate email address for issue reports. This value can be Base64-encoded.
	IssueMail *string `json:"issue_mail,omitempty" yaml:"issue_mail,omitempty" mapstructure:"issue_mail,omitempty"`

	// Persons who carry a key and are able to open the space upon request. One of the
	// fields irc_nick, phone, email or twitter must be specified.
	Keymasters []A15JsonContactKeymastersElem `json:"keymasters,omitempty" yaml:"keymasters,omitempty" mapstructure:"keymasters,omitempty"`

	// Mastodon username
	Mastodon *string `json:"mastodon,omitempty" yaml:"mastodon,omitempty" mapstructure:"mastodon,omitempty"`

	// Matrix channel/community for the Hackerspace
	Matrix *string `json:"matrix,omitempty" yaml:"matrix,omitempty" mapstructure:"matrix,omitempty"`

	// The e-mail address of your mailing list. If you use Google Groups then the
	// e-mail looks like <samp>your-group@googlegroups.com</samp>.
	Ml *string `json:"ml,omitempty" yaml:"ml,omitempty" mapstructure:"ml,omitempty"`

	// URL to a Mumble server/channel, as specified in
	// https://wiki.mumble.info/wiki/Mumble_URL
	Mumble *string `json:"mumble,omitempty" yaml:"mumble,omitempty" mapstructure:"mumble,omitempty"`

	// Phone number, including country code with a leading plus sign
	Phone *string `json:"phone,omitempty" yaml:"phone,omitempty" mapstructure:"phone,omitempty"`

	// URI for Voice-over-IP via SIP
	Sip *string `json:"sip,omitempty" yaml:"sip,omitempty" mapstructure:"sip,omitempty"`

	// Twitter username with leading <code>@</code>
	Twitter *string `json:"twitter,omitempty" yaml:"twitter,omitempty" mapstructure:"twitter,omitempty"`

	// A public Jabber/XMPP multi-user chatroom in the form
	// <samp>chatroom@conference.example.net</samp>
	Xmpp *string `json:"xmpp,omitempty" yaml:"xmpp,omitempty" mapstructure:"xmpp,omitempty"`
}

type A15JsonContactKeymastersElem struct {
	// Email address which can be base64 encoded.
	Email *string `json:"email,omitempty" yaml:"email,omitempty" mapstructure:"email,omitempty"`

	// Contact the person with this nickname directly in irc if available. The irc
	// channel to be used is defined in the contact/irc field.
	IrcNick *string `json:"irc_nick,omitempty" yaml:"irc_nick,omitempty" mapstructure:"irc_nick,omitempty"`

	// Mastodon username
	Mastodon *string `json:"mastodon,omitempty" yaml:"mastodon,omitempty" mapstructure:"mastodon,omitempty"`

	// Matrix username (including domain)
	Matrix *string `json:"matrix,omitempty" yaml:"matrix,omitempty" mapstructure:"matrix,omitempty"`

	// Real name
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Phone number, including country code with a leading plus sign
	Phone *string `json:"phone,omitempty" yaml:"phone,omitempty" mapstructure:"phone,omitempty"`

	// Twitter username with leading <code>@</code>
	Twitter *string `json:"twitter,omitempty" yaml:"twitter,omitempty" mapstructure:"twitter,omitempty"`

	// XMPP (Jabber) ID
	Xmpp *string `json:"xmpp,omitempty" yaml:"xmpp,omitempty" mapstructure:"xmpp,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15JsonContact) UnmarshalJSON(value []byte) error {
	type Plain A15JsonContact
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.Keymasters != nil && len(plain.Keymasters) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "keymasters", 1)
	}
	*j = A15JsonContact(plain)
	return nil
}

type A15JsonEventsElem struct {
	// A custom text field to give more information about the event
	Extra *string `json:"extra,omitempty" yaml:"extra,omitempty" mapstructure:"extra,omitempty"`

	// Name or other identity of the subject (e.g. <samp>J. Random Hacker</samp>,
	// <samp>fridge</samp>, <samp>3D printer</samp>, …)
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// The Unix timestamp (in seconds) when the event occurred.
	Timestamp float64 `json:"timestamp" yaml:"timestamp" mapstructure:"timestamp"`

	// Action (e.g. <samp>check-in</samp>, <samp>check-out</samp>,
	// <samp>finish-print</samp>, …). Define your own actions and use them
	// consistently, canonical actions are not (yet) specified
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15JsonEventsElem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in A15JsonEventsElem: required")
	}
	if _, ok := raw["timestamp"]; raw != nil && !ok {
		return fmt.Errorf("field timestamp in A15JsonEventsElem: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in A15JsonEventsElem: required")
	}
	type Plain A15JsonEventsElem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = A15JsonEventsElem(plain)
	return nil
}

// Feeds where users can get updates of your space
type A15JsonFeeds struct {
	// Blog corresponds to the JSON schema field "blog".
	Blog *A15JsonFeedsBlog `json:"blog,omitempty" yaml:"blog,omitempty" mapstructure:"blog,omitempty"`

	// Calendar corresponds to the JSON schema field "calendar".
	Calendar *A15JsonFeedsCalendar `json:"calendar,omitempty" yaml:"calendar,omitempty" mapstructure:"calendar,omitempty"`

	// Flickr corresponds to the JSON schema field "flickr".
	Flickr *A15JsonFeedsFlickr `json:"flickr,omitempty" yaml:"flickr,omitempty" mapstructure:"flickr,omitempty"`

	// Wiki corresponds to the JSON schema field "wiki".
	Wiki *A15JsonFeedsWiki `json:"wiki,omitempty" yaml:"wiki,omitempty" mapstructure:"wiki,omitempty"`
}

type A15JsonFeedsBlog struct {
	// Type of the feed
	Type *string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`

	// Feed URL
	Url string `json:"url" yaml:"url" mapstructure:"url"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15JsonFeedsBlog) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["url"]; raw != nil && !ok {
		return fmt.Errorf("field url in A15JsonFeedsBlog: required")
	}
	type Plain A15JsonFeedsBlog
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = A15JsonFeedsBlog(plain)
	return nil
}

type A15JsonFeedsCalendar struct {
	// Type of the feed
	Type *string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`

	// Feed URL
	Url string `json:"url" yaml:"url" mapstructure:"url"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15JsonFeedsCalendar) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["url"]; raw != nil && !ok {
		return fmt.Errorf("field url in A15JsonFeedsCalendar: required")
	}
	type Plain A15JsonFeedsCalendar
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = A15JsonFeedsCalendar(plain)
	return nil
}

type A15JsonFeedsFlickr struct {
	// Type of the feed
	Type *string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`

	// Feed URL
	Url string `json:"url" yaml:"url" mapstructure:"url"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15JsonFeedsFlickr) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["url"]; raw != nil && !ok {
		return fmt.Errorf("field url in A15JsonFeedsFlickr: required")
	}
	type Plain A15JsonFeedsFlickr
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = A15JsonFeedsFlickr(plain)
	return nil
}

type A15JsonFeedsWiki struct {
	// Type of the feed
	Type *string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`

	// Feed URL
	Url string `json:"url" yaml:"url" mapstructure:"url"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15JsonFeedsWiki) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["url"]; raw != nil && !ok {
		return fmt.Errorf("field url in A15JsonFeedsWiki: required")
	}
	type Plain A15JsonFeedsWiki
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = A15JsonFeedsWiki(plain)
	return nil
}

type A15JsonLinksElem struct {
	// An extra field for a more detailed description of the link
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// The link name.
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// The URL.
	Url string `json:"url" yaml:"url" mapstructure:"url"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15JsonLinksElem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in A15JsonLinksElem: required")
	}
	if _, ok := raw["url"]; raw != nil && !ok {
		return fmt.Errorf("field url in A15JsonLinksElem: required")
	}
	type Plain A15JsonLinksElem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = A15JsonLinksElem(plain)
	return nil
}

// Position data such as a postal address or geographic coordinates. May be omitted
// for spaces without a fixed physical location.
type A15JsonLocation struct {
	// The postal address of your space (street, block, housenumber, zip code, city,
	// whatever you usually need in your country, and the country
	// itself).<br>Examples: <ul><li>Netzladen e.V., Breite Straße 74, 53111 Bonn,
	// Germany</li></ul>
	Address *string `json:"address,omitempty" yaml:"address,omitempty" mapstructure:"address,omitempty"`

	// A list of areas in your space. Must include at least 1 area if defined.
	Areas []A15JsonLocationAreasElem `json:"areas,omitempty" yaml:"areas,omitempty" mapstructure:"areas,omitempty"`

	// Country code in ISO 3166 alpha-2 format
	CountryCode *string `json:"country_code,omitempty" yaml:"country_code,omitempty" mapstructure:"country_code,omitempty"`

	// Information that can be used to describe how to access your space, if it is not
	// trivial to find when standing at the address
	Hint *string `json:"hint,omitempty" yaml:"hint,omitempty" mapstructure:"hint,omitempty"`

	// Latitude of your space location, in degree with decimal places. Use positive
	// values for locations north of the equator, negative values for locations south
	// of equator.
	Lat *float64 `json:"lat,omitempty" yaml:"lat,omitempty" mapstructure:"lat,omitempty"`

	// Longitude of your space location, in degree with decimal places. Use positive
	// values for locations east of Greenwich, and negative values for locations west
	// of Greenwich.
	Lon *float64 `json:"lon,omitempty" yaml:"lon,omitempty" mapstructure:"lon,omitempty"`

	// The timezone the space is located in. It should be formatted according to the
	// <a target="_blank"
	// href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">TZ database
	// location names</a>.
	Timezone *string `json:"timezone,omitempty" yaml:"timezone,omitempty" mapstructure:"timezone,omitempty"`
}

type A15JsonLocationAreasElem struct {
	// A description of this area
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// The name of this area
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// The size of this area in square meters
	SquareMeters float64 `json:"square_meters" yaml:"square_meters" mapstructure:"square_meters"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15JsonLocationAreasElem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["square_meters"]; raw != nil && !ok {
		return fmt.Errorf("field square_meters in A15JsonLocationAreasElem: required")
	}
	type Plain A15JsonLocationAreasElem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = A15JsonLocationAreasElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15JsonLocation) UnmarshalJSON(value []byte) error {
	type Plain A15JsonLocation
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.Areas != nil && len(plain.Areas) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "areas", 1)
	}
	*j = A15JsonLocation(plain)
	return nil
}

type A15JsonMembershipPlansElem struct {
	// How often is the membership billed? If you select other, please specify in the
	// description what your billing interval is.
	BillingInterval A15JsonMembershipPlansElemBillingInterval `json:"billing_interval" yaml:"billing_interval" mapstructure:"billing_interval"`

	// What's the currency? It should be formatted according to <a
	// href="https://en.wikipedia.org/wiki/ISO_4217" target="_blank">ISO 4217</a>
	// short-code format.
	Currency string `json:"currency" yaml:"currency" mapstructure:"currency"`

	// A free form string.
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// The name of the membership plan
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// How much does this plan cost?
	Value float64 `json:"value" yaml:"value" mapstructure:"value"`
}

type A15JsonMembershipPlansElemBillingInterval string

const A15JsonMembershipPlansElemBillingIntervalDaily A15JsonMembershipPlansElemBillingInterval = "daily"
const A15JsonMembershipPlansElemBillingIntervalHourly A15JsonMembershipPlansElemBillingInterval = "hourly"
const A15JsonMembershipPlansElemBillingIntervalMonthly A15JsonMembershipPlansElemBillingInterval = "monthly"
const A15JsonMembershipPlansElemBillingIntervalOther A15JsonMembershipPlansElemBillingInterval = "other"
const A15JsonMembershipPlansElemBillingIntervalQuarterly A15JsonMembershipPlansElemBillingInterval = "quarterly"
const A15JsonMembershipPlansElemBillingIntervalWeekly A15JsonMembershipPlansElemBillingInterval = "weekly"
const A15JsonMembershipPlansElemBillingIntervalYearly A15JsonMembershipPlansElemBillingInterval = "yearly"

var enumValues_A15JsonMembershipPlansElemBillingInterval = []interface{}{
	"yearly",
	"quarterly",
	"monthly",
	"weekly",
	"daily",
	"hourly",
	"other",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15JsonMembershipPlansElemBillingInterval) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_A15JsonMembershipPlansElemBillingInterval {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_A15JsonMembershipPlansElemBillingInterval, v)
	}
	*j = A15JsonMembershipPlansElemBillingInterval(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15JsonMembershipPlansElem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["billing_interval"]; raw != nil && !ok {
		return fmt.Errorf("field billing_interval in A15JsonMembershipPlansElem: required")
	}
	if _, ok := raw["currency"]; raw != nil && !ok {
		return fmt.Errorf("field currency in A15JsonMembershipPlansElem: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in A15JsonMembershipPlansElem: required")
	}
	if _, ok := raw["value"]; raw != nil && !ok {
		return fmt.Errorf("field value in A15JsonMembershipPlansElem: required")
	}
	type Plain A15JsonMembershipPlansElem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = A15JsonMembershipPlansElem(plain)
	return nil
}

// Data of various sensors in your space (e.g. temperature, humidity, amount of
// Club-Mate left, …). The only canonical property is the <em>temp</em> property,
// additional sensor types may be defined by you. In this case, you are requested
// to share your definition for inclusion in this specification.
type A15JsonSensors struct {
	// How rich is your hackerspace?
	AccountBalance []A15JsonSensorsAccountBalanceElem `json:"account_balance,omitempty" yaml:"account_balance,omitempty" mapstructure:"account_balance,omitempty"`

	// Barometer sensor
	Barometer []A15JsonSensorsBarometerElem `json:"barometer,omitempty" yaml:"barometer,omitempty" mapstructure:"barometer,omitempty"`

	// How much Mate and beer is in your fridge?
	BeverageSupply []A15JsonSensorsBeverageSupplyElem `json:"beverage_supply,omitempty" yaml:"beverage_supply,omitempty" mapstructure:"beverage_supply,omitempty"`

	// CO2 sensor
	Carbondioxide []A15JsonSensorsCarbondioxideElem `json:"carbondioxide,omitempty" yaml:"carbondioxide,omitempty" mapstructure:"carbondioxide,omitempty"`

	// Sensor type to indicate if a certain door is locked.
	DoorLocked []A15JsonSensorsDoorLockedElem `json:"door_locked,omitempty" yaml:"door_locked,omitempty" mapstructure:"door_locked,omitempty"`

	// Humidity sensor
	Humidity []A15JsonSensorsHumidityElem `json:"humidity,omitempty" yaml:"humidity,omitempty" mapstructure:"humidity,omitempty"`

	// This sensor type is to specify the currently active ethernet or wireless
	// network devices. You can create different instances for each network type.
	NetworkConnections []A15JsonSensorsNetworkConnectionsElem `json:"network_connections,omitempty" yaml:"network_connections,omitempty" mapstructure:"network_connections,omitempty"`

	// The current network traffic, in bits/second or packets/second (or both)
	NetworkTraffic []A15JsonSensorsNetworkTrafficElem `json:"network_traffic,omitempty" yaml:"network_traffic,omitempty" mapstructure:"network_traffic,omitempty"`

	// Specify the number of people that are currently in your space. Optionally you
	// can define a list of names.
	PeopleNowPresent []A15JsonSensorsPeopleNowPresentElem `json:"people_now_present,omitempty" yaml:"people_now_present,omitempty" mapstructure:"people_now_present,omitempty"`

	// The power consumption of a specific device or of your whole space
	PowerConsumption []A15JsonSensorsPowerConsumptionElem `json:"power_consumption,omitempty" yaml:"power_consumption,omitempty" mapstructure:"power_consumption,omitempty"`

	// The power generation of a specific device or of your whole space
	PowerGeneration []A15JsonSensorsPowerGenerationElem `json:"power_generation,omitempty" yaml:"power_generation,omitempty" mapstructure:"power_generation,omitempty"`

	// Compound radiation sensor. Check this <a rel="nofollow"
	// href="https://sites.google.com/site/diygeigercounter/technical/gm-tubes-supported"
	// target="_blank">resource</a>.
	Radiation *A15JsonSensorsRadiation `json:"radiation,omitempty" yaml:"radiation,omitempty" mapstructure:"radiation,omitempty"`

	// Temperature sensor. To convert from one unit of temperature to another consider
	// <a href="http://en.wikipedia.org/wiki/Temperature_conversion_formulas"
	// target="_blank">Wikipedia</a>.
	Temperature []A15JsonSensorsTemperatureElem `json:"temperature,omitempty" yaml:"temperature,omitempty" mapstructure:"temperature,omitempty"`

	// Specify the number of space members.
	TotalMemberCount []A15JsonSensorsTotalMemberCountElem `json:"total_member_count,omitempty" yaml:"total_member_count,omitempty" mapstructure:"total_member_count,omitempty"`

	// Your wind sensor
	Wind []A15JsonSensorsWindElem `json:"wind,omitempty" yaml:"wind,omitempty" mapstructure:"wind,omitempty"`
}

type A15JsonSensorsAccountBalanceElem struct {
	// An extra field that you can use to attach some additional information to this
	// sensor instance
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// The Unix timestamp (in seconds) when the sensor value changed most recently
	Lastchange *float64 `json:"lastchange,omitempty" yaml:"lastchange,omitempty" mapstructure:"lastchange,omitempty"`

	// If you have more than one account you can use this field to specify where it
	// is.
	Location *string `json:"location,omitempty" yaml:"location,omitempty" mapstructure:"location,omitempty"`

	// Give your sensor instance a name.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// What's the currency? It should be formatted according to <a
	// href="https://en.wikipedia.org/wiki/ISO_4217" target="_blank">ISO 4217</a>
	// short-code format.
	Unit string `json:"unit" yaml:"unit" mapstructure:"unit"`

	// How much?
	Value float64 `json:"value" yaml:"value" mapstructure:"value"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15JsonSensorsAccountBalanceElem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["unit"]; raw != nil && !ok {
		return fmt.Errorf("field unit in A15JsonSensorsAccountBalanceElem: required")
	}
	if _, ok := raw["value"]; raw != nil && !ok {
		return fmt.Errorf("field value in A15JsonSensorsAccountBalanceElem: required")
	}
	type Plain A15JsonSensorsAccountBalanceElem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = A15JsonSensorsAccountBalanceElem(plain)
	return nil
}

type A15JsonSensorsBarometerElem struct {
	// An extra field that you can use to attach some additional information to this
	// sensor instance
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// The Unix timestamp (in seconds) when the sensor value changed most recently
	Lastchange *float64 `json:"lastchange,omitempty" yaml:"lastchange,omitempty" mapstructure:"lastchange,omitempty"`

	// The location of your sensor
	Location string `json:"location" yaml:"location" mapstructure:"location"`

	// This field is an additional field to give your sensor a name. This can be
	// useful if you have multiple sensors in the same location.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// The unit of pressure used by your sensor
	Unit A15JsonSensorsBarometerElemUnit `json:"unit" yaml:"unit" mapstructure:"unit"`

	// The sensor value
	Value float64 `json:"value" yaml:"value" mapstructure:"value"`
}

type A15JsonSensorsBarometerElemUnit string

const A15JsonSensorsBarometerElemUnitHPa A15JsonSensorsBarometerElemUnit = "hPa"

var enumValues_A15JsonSensorsBarometerElemUnit = []interface{}{
	"hPa",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15JsonSensorsBarometerElemUnit) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_A15JsonSensorsBarometerElemUnit {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_A15JsonSensorsBarometerElemUnit, v)
	}
	*j = A15JsonSensorsBarometerElemUnit(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15JsonSensorsBarometerElem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["location"]; raw != nil && !ok {
		return fmt.Errorf("field location in A15JsonSensorsBarometerElem: required")
	}
	if _, ok := raw["unit"]; raw != nil && !ok {
		return fmt.Errorf("field unit in A15JsonSensorsBarometerElem: required")
	}
	if _, ok := raw["value"]; raw != nil && !ok {
		return fmt.Errorf("field value in A15JsonSensorsBarometerElem: required")
	}
	type Plain A15JsonSensorsBarometerElem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = A15JsonSensorsBarometerElem(plain)
	return nil
}

type A15JsonSensorsBeverageSupplyElem struct {
	// An extra field that you can use to attach some additional information to this
	// sensor instance
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// The Unix timestamp (in seconds) when the sensor value changed most recently
	Lastchange *float64 `json:"lastchange,omitempty" yaml:"lastchange,omitempty" mapstructure:"lastchange,omitempty"`

	// The location of your sensor
	Location *string `json:"location,omitempty" yaml:"location,omitempty" mapstructure:"location,omitempty"`

	// This field is an additional field to give your sensor a name. This can be
	// useful if you have multiple sensors in the same location.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// The unit, either <samp>btl</samp> for bottles or <samp>crt</samp> for crates
	Unit A15JsonSensorsBeverageSupplyElemUnit `json:"unit" yaml:"unit" mapstructure:"unit"`

	// The sensor value
	Value float64 `json:"value" yaml:"value" mapstructure:"value"`
}

type A15JsonSensorsBeverageSupplyElemUnit string

const A15JsonSensorsBeverageSupplyElemUnitBtl A15JsonSensorsBeverageSupplyElemUnit = "btl"
const A15JsonSensorsBeverageSupplyElemUnitCrt A15JsonSensorsBeverageSupplyElemUnit = "crt"

var enumValues_A15JsonSensorsBeverageSupplyElemUnit = []interface{}{
	"btl",
	"crt",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15JsonSensorsBeverageSupplyElemUnit) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_A15JsonSensorsBeverageSupplyElemUnit {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_A15JsonSensorsBeverageSupplyElemUnit, v)
	}
	*j = A15JsonSensorsBeverageSupplyElemUnit(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15JsonSensorsBeverageSupplyElem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["unit"]; raw != nil && !ok {
		return fmt.Errorf("field unit in A15JsonSensorsBeverageSupplyElem: required")
	}
	if _, ok := raw["value"]; raw != nil && !ok {
		return fmt.Errorf("field value in A15JsonSensorsBeverageSupplyElem: required")
	}
	type Plain A15JsonSensorsBeverageSupplyElem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = A15JsonSensorsBeverageSupplyElem(plain)
	return nil
}

type A15JsonSensorsCarbondioxideElem struct {
	// An extra field that you can use to attach some additional information to this
	// sensor instance
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// The Unix timestamp (in seconds) when the sensor value changed most recently
	Lastchange *float64 `json:"lastchange,omitempty" yaml:"lastchange,omitempty" mapstructure:"lastchange,omitempty"`

	// The location of your sensor
	Location string `json:"location" yaml:"location" mapstructure:"location"`

	// This field is an additional field to give your sensor a name. This can be
	// useful if you have multiple sensors in the same location.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// The unit of the sensor value.
	Unit A15JsonSensorsCarbondioxideElemUnit `json:"unit" yaml:"unit" mapstructure:"unit"`

	// The sensor value
	Value float64 `json:"value" yaml:"value" mapstructure:"value"`
}

type A15JsonSensorsCarbondioxideElemUnit string

const A15JsonSensorsCarbondioxideElemUnitPpm A15JsonSensorsCarbondioxideElemUnit = "ppm"
const A15JsonSensorsCarbondioxideElemUnitVol A15JsonSensorsCarbondioxideElemUnit = "vol%"

var enumValues_A15JsonSensorsCarbondioxideElemUnit = []interface{}{
	"ppm",
	"vol%",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15JsonSensorsCarbondioxideElemUnit) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_A15JsonSensorsCarbondioxideElemUnit {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_A15JsonSensorsCarbondioxideElemUnit, v)
	}
	*j = A15JsonSensorsCarbondioxideElemUnit(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15JsonSensorsCarbondioxideElem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["location"]; raw != nil && !ok {
		return fmt.Errorf("field location in A15JsonSensorsCarbondioxideElem: required")
	}
	if _, ok := raw["unit"]; raw != nil && !ok {
		return fmt.Errorf("field unit in A15JsonSensorsCarbondioxideElem: required")
	}
	if _, ok := raw["value"]; raw != nil && !ok {
		return fmt.Errorf("field value in A15JsonSensorsCarbondioxideElem: required")
	}
	type Plain A15JsonSensorsCarbondioxideElem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = A15JsonSensorsCarbondioxideElem(plain)
	return nil
}

type A15JsonSensorsDoorLockedElem struct {
	// An extra field that you can use to attach some additional information to this
	// sensor instance
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// The Unix timestamp (in seconds) when the sensor value changed most recently
	Lastchange *float64 `json:"lastchange,omitempty" yaml:"lastchange,omitempty" mapstructure:"lastchange,omitempty"`

	// The location of your sensor
	Location string `json:"location" yaml:"location" mapstructure:"location"`

	// This field is an additional field to give your sensor a name. This can be
	// useful if you have multiple sensors in the same location.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// The sensor value
	Value bool `json:"value" yaml:"value" mapstructure:"value"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15JsonSensorsDoorLockedElem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["location"]; raw != nil && !ok {
		return fmt.Errorf("field location in A15JsonSensorsDoorLockedElem: required")
	}
	if _, ok := raw["value"]; raw != nil && !ok {
		return fmt.Errorf("field value in A15JsonSensorsDoorLockedElem: required")
	}
	type Plain A15JsonSensorsDoorLockedElem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = A15JsonSensorsDoorLockedElem(plain)
	return nil
}

type A15JsonSensorsHumidityElem struct {
	// An extra field that you can use to attach some additional information to this
	// sensor instance
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// The Unix timestamp (in seconds) when the sensor value changed most recently
	Lastchange *float64 `json:"lastchange,omitempty" yaml:"lastchange,omitempty" mapstructure:"lastchange,omitempty"`

	// The location of your sensor
	Location string `json:"location" yaml:"location" mapstructure:"location"`

	// This field is an additional field to give your sensor a name. This can be
	// useful if you have multiple sensors in the same location.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// The humidity unit
	Unit A15JsonSensorsHumidityElemUnit `json:"unit" yaml:"unit" mapstructure:"unit"`

	// The sensor value
	Value float64 `json:"value" yaml:"value" mapstructure:"value"`
}

type A15JsonSensorsHumidityElemUnit string

const A15JsonSensorsHumidityElemUnitUndefined A15JsonSensorsHumidityElemUnit = "%"

var enumValues_A15JsonSensorsHumidityElemUnit = []interface{}{
	"%",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15JsonSensorsHumidityElemUnit) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_A15JsonSensorsHumidityElemUnit {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_A15JsonSensorsHumidityElemUnit, v)
	}
	*j = A15JsonSensorsHumidityElemUnit(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15JsonSensorsHumidityElem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["location"]; raw != nil && !ok {
		return fmt.Errorf("field location in A15JsonSensorsHumidityElem: required")
	}
	if _, ok := raw["unit"]; raw != nil && !ok {
		return fmt.Errorf("field unit in A15JsonSensorsHumidityElem: required")
	}
	if _, ok := raw["value"]; raw != nil && !ok {
		return fmt.Errorf("field value in A15JsonSensorsHumidityElem: required")
	}
	type Plain A15JsonSensorsHumidityElem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = A15JsonSensorsHumidityElem(plain)
	return nil
}

type A15JsonSensorsNetworkConnectionsElem struct {
	// An extra field that you can use to attach some additional information to this
	// sensor instance
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// The Unix timestamp (in seconds) when the sensor value changed most recently
	Lastchange *float64 `json:"lastchange,omitempty" yaml:"lastchange,omitempty" mapstructure:"lastchange,omitempty"`

	// The location of your sensor
	Location *string `json:"location,omitempty" yaml:"location,omitempty" mapstructure:"location,omitempty"`

	// The machines that are currently connected with the network.
	Machines []A15JsonSensorsNetworkConnectionsElemMachinesElem `json:"machines,omitempty" yaml:"machines,omitempty" mapstructure:"machines,omitempty"`

	// This field is an additional field to give your sensor a name. This can be
	// useful if you have multiple sensors in the same location.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// This field is optional but you can use it to the network type such as
	// <samp>wifi</samp> or <samp>cable</samp>. You can even expose the number of <a
	// href="https://spacefed.net/wiki/index.php/Spacenet"
	// target="_blank">spacenet</a>-authenticated connections.
	Type *A15JsonSensorsNetworkConnectionsElemType `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`

	// The amount of network connections.
	Value float64 `json:"value" yaml:"value" mapstructure:"value"`
}

type A15JsonSensorsNetworkConnectionsElemMachinesElem struct {
	// The machine's MAC address of the format <samp>D3:3A:DB:EE:FF:00</samp>.
	Mac string `json:"mac" yaml:"mac" mapstructure:"mac"`

	// The machine name.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15JsonSensorsNetworkConnectionsElemMachinesElem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["mac"]; raw != nil && !ok {
		return fmt.Errorf("field mac in A15JsonSensorsNetworkConnectionsElemMachinesElem: required")
	}
	type Plain A15JsonSensorsNetworkConnectionsElemMachinesElem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = A15JsonSensorsNetworkConnectionsElemMachinesElem(plain)
	return nil
}

type A15JsonSensorsNetworkConnectionsElemType string

const A15JsonSensorsNetworkConnectionsElemTypeCable A15JsonSensorsNetworkConnectionsElemType = "cable"
const A15JsonSensorsNetworkConnectionsElemTypeSpacenet A15JsonSensorsNetworkConnectionsElemType = "spacenet"
const A15JsonSensorsNetworkConnectionsElemTypeWifi A15JsonSensorsNetworkConnectionsElemType = "wifi"

var enumValues_A15JsonSensorsNetworkConnectionsElemType = []interface{}{
	"wifi",
	"cable",
	"spacenet",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15JsonSensorsNetworkConnectionsElemType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_A15JsonSensorsNetworkConnectionsElemType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_A15JsonSensorsNetworkConnectionsElemType, v)
	}
	*j = A15JsonSensorsNetworkConnectionsElemType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15JsonSensorsNetworkConnectionsElem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["value"]; raw != nil && !ok {
		return fmt.Errorf("field value in A15JsonSensorsNetworkConnectionsElem: required")
	}
	type Plain A15JsonSensorsNetworkConnectionsElem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = A15JsonSensorsNetworkConnectionsElem(plain)
	return nil
}

type A15JsonSensorsNetworkTrafficElem struct {
	// An extra field that you can use to attach some additional information to this
	// sensor instance
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// The Unix timestamp (in seconds) when the sensor value changed most recently
	Lastchange *float64 `json:"lastchange,omitempty" yaml:"lastchange,omitempty" mapstructure:"lastchange,omitempty"`

	// Location the measurement relates to, e.g. <samp>WiFi</samp> or
	// <samp>Uplink</samp>
	Location *string `json:"location,omitempty" yaml:"location,omitempty" mapstructure:"location,omitempty"`

	// Name of the measurement, e.g. to distinguish between upstream and downstream
	// traffic
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Properties corresponds to the JSON schema field "properties".
	Properties A15JsonSensorsNetworkTrafficElemProperties `json:"properties" yaml:"properties" mapstructure:"properties"`
}

type A15JsonSensorsNetworkTrafficElemProperties struct {
	// BitsPerSecond corresponds to the JSON schema field "bits_per_second".
	BitsPerSecond *A15JsonSensorsNetworkTrafficElemPropertiesBitsPerSecond `json:"bits_per_second,omitempty" yaml:"bits_per_second,omitempty" mapstructure:"bits_per_second,omitempty"`

	// PacketsPerSecond corresponds to the JSON schema field "packets_per_second".
	PacketsPerSecond *A15JsonSensorsNetworkTrafficElemPropertiesPacketsPerSecond `json:"packets_per_second,omitempty" yaml:"packets_per_second,omitempty" mapstructure:"packets_per_second,omitempty"`
}

type A15JsonSensorsNetworkTrafficElemPropertiesBitsPerSecond struct {
	// The maximum available throughput in bits/second, e.g. as sold by your ISP
	Maximum *float64 `json:"maximum,omitempty" yaml:"maximum,omitempty" mapstructure:"maximum,omitempty"`

	// The measurement value, in bits/second
	Value float64 `json:"value" yaml:"value" mapstructure:"value"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15JsonSensorsNetworkTrafficElemPropertiesBitsPerSecond) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["value"]; raw != nil && !ok {
		return fmt.Errorf("field value in A15JsonSensorsNetworkTrafficElemPropertiesBitsPerSecond: required")
	}
	type Plain A15JsonSensorsNetworkTrafficElemPropertiesBitsPerSecond
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.Maximum != nil && 0 > *plain.Maximum {
		return fmt.Errorf("field %s: must be >= %v", "maximum", 0)
	}
	if 0 > plain.Value {
		return fmt.Errorf("field %s: must be >= %v", "value", 0)
	}
	*j = A15JsonSensorsNetworkTrafficElemPropertiesBitsPerSecond(plain)
	return nil
}

type A15JsonSensorsNetworkTrafficElemPropertiesPacketsPerSecond struct {
	// The measurement value, in packets/second
	Value float64 `json:"value" yaml:"value" mapstructure:"value"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15JsonSensorsNetworkTrafficElemPropertiesPacketsPerSecond) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["value"]; raw != nil && !ok {
		return fmt.Errorf("field value in A15JsonSensorsNetworkTrafficElemPropertiesPacketsPerSecond: required")
	}
	type Plain A15JsonSensorsNetworkTrafficElemPropertiesPacketsPerSecond
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if 0 > plain.Value {
		return fmt.Errorf("field %s: must be >= %v", "value", 0)
	}
	*j = A15JsonSensorsNetworkTrafficElemPropertiesPacketsPerSecond(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15JsonSensorsNetworkTrafficElem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["properties"]; raw != nil && !ok {
		return fmt.Errorf("field properties in A15JsonSensorsNetworkTrafficElem: required")
	}
	type Plain A15JsonSensorsNetworkTrafficElem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = A15JsonSensorsNetworkTrafficElem(plain)
	return nil
}

type A15JsonSensorsPeopleNowPresentElem struct {
	// An extra field that you can use to attach some additional information to this
	// sensor instance
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// The Unix timestamp (in seconds) when the sensor value changed most recently
	Lastchange *float64 `json:"lastchange,omitempty" yaml:"lastchange,omitempty" mapstructure:"lastchange,omitempty"`

	// If you use multiple sensor instances for different rooms, use this field to
	// indicate the location.
	Location *string `json:"location,omitempty" yaml:"location,omitempty" mapstructure:"location,omitempty"`

	// Give this sensor a name if necessary at all. Use the location field for the
	// rooms. This field is not intended to be used for names of hackerspace members.
	// Use the field 'names' instead.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// List of hackerspace members that are currently occupying the space.
	Names []string `json:"names,omitempty" yaml:"names,omitempty" mapstructure:"names,omitempty"`

	// The amount of present people.
	Value float64 `json:"value" yaml:"value" mapstructure:"value"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15JsonSensorsPeopleNowPresentElem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["value"]; raw != nil && !ok {
		return fmt.Errorf("field value in A15JsonSensorsPeopleNowPresentElem: required")
	}
	type Plain A15JsonSensorsPeopleNowPresentElem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.Names != nil && len(plain.Names) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "names", 1)
	}
	*j = A15JsonSensorsPeopleNowPresentElem(plain)
	return nil
}

type A15JsonSensorsPowerConsumptionElem struct {
	// An extra field that you can use to attach some additional information to this
	// sensor instance
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// The Unix timestamp (in seconds) when the sensor value changed most recently
	Lastchange *float64 `json:"lastchange,omitempty" yaml:"lastchange,omitempty" mapstructure:"lastchange,omitempty"`

	// The location of your sensor
	Location string `json:"location" yaml:"location" mapstructure:"location"`

	// This field is an additional field to give your sensor a name. This can be
	// useful if you have multiple sensors in the same location.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// The power unit
	Unit A15JsonSensorsPowerConsumptionElemUnit `json:"unit" yaml:"unit" mapstructure:"unit"`

	// The sensor value
	Value float64 `json:"value" yaml:"value" mapstructure:"value"`
}

type A15JsonSensorsPowerConsumptionElemUnit string

const A15JsonSensorsPowerConsumptionElemUnitVA A15JsonSensorsPowerConsumptionElemUnit = "VA"
const A15JsonSensorsPowerConsumptionElemUnitW A15JsonSensorsPowerConsumptionElemUnit = "W"

var enumValues_A15JsonSensorsPowerConsumptionElemUnit = []interface{}{
	"W",
	"VA",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15JsonSensorsPowerConsumptionElemUnit) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_A15JsonSensorsPowerConsumptionElemUnit {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_A15JsonSensorsPowerConsumptionElemUnit, v)
	}
	*j = A15JsonSensorsPowerConsumptionElemUnit(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15JsonSensorsPowerConsumptionElem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["location"]; raw != nil && !ok {
		return fmt.Errorf("field location in A15JsonSensorsPowerConsumptionElem: required")
	}
	if _, ok := raw["unit"]; raw != nil && !ok {
		return fmt.Errorf("field unit in A15JsonSensorsPowerConsumptionElem: required")
	}
	if _, ok := raw["value"]; raw != nil && !ok {
		return fmt.Errorf("field value in A15JsonSensorsPowerConsumptionElem: required")
	}
	type Plain A15JsonSensorsPowerConsumptionElem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = A15JsonSensorsPowerConsumptionElem(plain)
	return nil
}

type A15JsonSensorsPowerGenerationElem struct {
	// An extra field that you can use to attach some additional information to this
	// sensor instance
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// The Unix timestamp (in seconds) when the sensor value changed most recently
	Lastchange *float64 `json:"lastchange,omitempty" yaml:"lastchange,omitempty" mapstructure:"lastchange,omitempty"`

	// The location of your sensor
	Location string `json:"location" yaml:"location" mapstructure:"location"`

	// This field is an additional field to give your sensor a name. This can be
	// useful if you have multiple sensors in the same location.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// The unit of the sensor value.
	Unit A15JsonSensorsPowerGenerationElemUnit `json:"unit" yaml:"unit" mapstructure:"unit"`

	// The sensor value
	Value float64 `json:"value" yaml:"value" mapstructure:"value"`
}

type A15JsonSensorsPowerGenerationElemUnit string

const A15JsonSensorsPowerGenerationElemUnitVA A15JsonSensorsPowerGenerationElemUnit = "VA"
const A15JsonSensorsPowerGenerationElemUnitW A15JsonSensorsPowerGenerationElemUnit = "W"

var enumValues_A15JsonSensorsPowerGenerationElemUnit = []interface{}{
	"W",
	"VA",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15JsonSensorsPowerGenerationElemUnit) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_A15JsonSensorsPowerGenerationElemUnit {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_A15JsonSensorsPowerGenerationElemUnit, v)
	}
	*j = A15JsonSensorsPowerGenerationElemUnit(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15JsonSensorsPowerGenerationElem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["location"]; raw != nil && !ok {
		return fmt.Errorf("field location in A15JsonSensorsPowerGenerationElem: required")
	}
	if _, ok := raw["unit"]; raw != nil && !ok {
		return fmt.Errorf("field unit in A15JsonSensorsPowerGenerationElem: required")
	}
	if _, ok := raw["value"]; raw != nil && !ok {
		return fmt.Errorf("field value in A15JsonSensorsPowerGenerationElem: required")
	}
	type Plain A15JsonSensorsPowerGenerationElem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = A15JsonSensorsPowerGenerationElem(plain)
	return nil
}

// Compound radiation sensor. Check this <a rel="nofollow"
// href="https://sites.google.com/site/diygeigercounter/technical/gm-tubes-supported"
// target="_blank">resource</a>.
type A15JsonSensorsRadiation struct {
	// An alpha sensor
	Alpha []A15JsonSensorsRadiationAlphaElem `json:"alpha,omitempty" yaml:"alpha,omitempty" mapstructure:"alpha,omitempty"`

	// A beta sensor
	Beta []A15JsonSensorsRadiationBetaElem `json:"beta,omitempty" yaml:"beta,omitempty" mapstructure:"beta,omitempty"`

	// A sensor which cannot filter beta and gamma radiation separately.
	BetaGamma []A15JsonSensorsRadiationBetaGammaElem `json:"beta_gamma,omitempty" yaml:"beta_gamma,omitempty" mapstructure:"beta_gamma,omitempty"`

	// A gamma sensor
	Gamma []A15JsonSensorsRadiationGammaElem `json:"gamma,omitempty" yaml:"gamma,omitempty" mapstructure:"gamma,omitempty"`
}

type A15JsonSensorsRadiationAlphaElem struct {
	// The conversion from the <em>cpm</em> unit to another unit hardly depends on
	// your tube type. See the description of the value field to see how to use the
	// conversion factor. <strong>Note:</strong> only trust your manufacturer if it
	// comes to the actual factor value. The internet seems <a rel="nofollow"
	// href="http://sapporohibaku.wordpress.com/2011/10/15/conversion-factor/"
	// target="_blank">full of wrong copy & pastes</a>, don't even trust your
	// neighbour hackerspace. If in doubt ask the tube manufacturer.
	ConversionFactor *float64 `json:"conversion_factor,omitempty" yaml:"conversion_factor,omitempty" mapstructure:"conversion_factor,omitempty"`

	// The dead time in µs. See the description of the value field to see how to use
	// the dead time.
	DeadTime *float64 `json:"dead_time,omitempty" yaml:"dead_time,omitempty" mapstructure:"dead_time,omitempty"`

	// An extra field that you can use to attach some additional information to this
	// sensor instance
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// The Unix timestamp (in seconds) when the sensor value changed most recently
	Lastchange *float64 `json:"lastchange,omitempty" yaml:"lastchange,omitempty" mapstructure:"lastchange,omitempty"`

	// The location of your sensor
	Location *string `json:"location,omitempty" yaml:"location,omitempty" mapstructure:"location,omitempty"`

	// This field is an additional field to give your sensor a name. This can be
	// useful if you have multiple sensors in the same location.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Choose the appropriate unit for your radiation sensor instance
	Unit A15JsonSensorsRadiationAlphaElemUnit `json:"unit" yaml:"unit" mapstructure:"unit"`

	// Observed counts per minute (ocpm) or actual radiation value. If the value are
	// the observed counts then the dead_time and conversion_factor fields must be
	// defined as well. CPM formula: <div>cpm = ocpm ( 1 + 1 / (1 - ocpm x dead_time)
	// )</div> Conversion formula: <div>µSv/h = cpm x conversion_factor</div>
	Value float64 `json:"value" yaml:"value" mapstructure:"value"`
}

type A15JsonSensorsRadiationAlphaElemUnit string

const A15JsonSensorsRadiationAlphaElemUnitCpm A15JsonSensorsRadiationAlphaElemUnit = "cpm"
const A15JsonSensorsRadiationAlphaElemUnitMSvA A15JsonSensorsRadiationAlphaElemUnit = "mSv/a"
const A15JsonSensorsRadiationAlphaElemUnitRH A15JsonSensorsRadiationAlphaElemUnit = "r/h"

var enumValues_A15JsonSensorsRadiationAlphaElemUnit = []interface{}{
	"cpm",
	"r/h",
	"µSv/h",
	"mSv/a",
	"µSv/a",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15JsonSensorsRadiationAlphaElemUnit) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_A15JsonSensorsRadiationAlphaElemUnit {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_A15JsonSensorsRadiationAlphaElemUnit, v)
	}
	*j = A15JsonSensorsRadiationAlphaElemUnit(v)
	return nil
}

const A15JsonSensorsRadiationAlphaElemUnitΜSvA A15JsonSensorsRadiationAlphaElemUnit = "µSv/a"
const A15JsonSensorsRadiationAlphaElemUnitΜSvH A15JsonSensorsRadiationAlphaElemUnit = "µSv/h"

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15JsonSensorsRadiationAlphaElem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["unit"]; raw != nil && !ok {
		return fmt.Errorf("field unit in A15JsonSensorsRadiationAlphaElem: required")
	}
	if _, ok := raw["value"]; raw != nil && !ok {
		return fmt.Errorf("field value in A15JsonSensorsRadiationAlphaElem: required")
	}
	type Plain A15JsonSensorsRadiationAlphaElem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = A15JsonSensorsRadiationAlphaElem(plain)
	return nil
}

type A15JsonSensorsRadiationBetaElem struct {
	// The conversion from the <em>cpm</em> unit to another unit hardly depends on
	// your tube type. See the description of the value field to see how to use the
	// conversion factor. <strong>Note:</strong> only trust your manufacturer if it
	// comes to the actual factor value. The internet seems <a rel="nofollow"
	// href="http://sapporohibaku.wordpress.com/2011/10/15/conversion-factor/"
	// target="_blank">full of wrong copy & pastes</a>, don't even trust your
	// neighbour hackerspace. If in doubt ask the tube manufacturer.
	ConversionFactor *float64 `json:"conversion_factor,omitempty" yaml:"conversion_factor,omitempty" mapstructure:"conversion_factor,omitempty"`

	// The dead time in µs. See the description of the value field to see how to use
	// the dead time.
	DeadTime *float64 `json:"dead_time,omitempty" yaml:"dead_time,omitempty" mapstructure:"dead_time,omitempty"`

	// An extra field that you can use to attach some additional information to this
	// sensor instance
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// The Unix timestamp (in seconds) when the sensor value changed most recently
	Lastchange *float64 `json:"lastchange,omitempty" yaml:"lastchange,omitempty" mapstructure:"lastchange,omitempty"`

	// The location of your sensor
	Location *string `json:"location,omitempty" yaml:"location,omitempty" mapstructure:"location,omitempty"`

	// This field is an additional field to give your sensor a name. This can be
	// useful if you have multiple sensors in the same location.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Choose the appropriate unit for your radiation sensor instance
	Unit A15JsonSensorsRadiationBetaElemUnit `json:"unit" yaml:"unit" mapstructure:"unit"`

	// Observed counts per minute (ocpm) or actual radiation value. If the value are
	// the observed counts then the dead_time and conversion_factor fields must be
	// defined as well. CPM formula: <div>cpm = ocpm ( 1 + 1 / (1 - ocpm x dead_time)
	// )</div> Conversion formula: <div>µSv/h = cpm x conversion_factor</div>
	Value float64 `json:"value" yaml:"value" mapstructure:"value"`
}

type A15JsonSensorsRadiationBetaElemUnit string

const A15JsonSensorsRadiationBetaElemUnitCpm A15JsonSensorsRadiationBetaElemUnit = "cpm"
const A15JsonSensorsRadiationBetaElemUnitMSvA A15JsonSensorsRadiationBetaElemUnit = "mSv/a"
const A15JsonSensorsRadiationBetaElemUnitRH A15JsonSensorsRadiationBetaElemUnit = "r/h"

var enumValues_A15JsonSensorsRadiationBetaElemUnit = []interface{}{
	"cpm",
	"r/h",
	"µSv/h",
	"mSv/a",
	"µSv/a",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15JsonSensorsRadiationBetaElemUnit) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_A15JsonSensorsRadiationBetaElemUnit {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_A15JsonSensorsRadiationBetaElemUnit, v)
	}
	*j = A15JsonSensorsRadiationBetaElemUnit(v)
	return nil
}

const A15JsonSensorsRadiationBetaElemUnitΜSvA A15JsonSensorsRadiationBetaElemUnit = "µSv/a"
const A15JsonSensorsRadiationBetaElemUnitΜSvH A15JsonSensorsRadiationBetaElemUnit = "µSv/h"

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15JsonSensorsRadiationBetaElem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["unit"]; raw != nil && !ok {
		return fmt.Errorf("field unit in A15JsonSensorsRadiationBetaElem: required")
	}
	if _, ok := raw["value"]; raw != nil && !ok {
		return fmt.Errorf("field value in A15JsonSensorsRadiationBetaElem: required")
	}
	type Plain A15JsonSensorsRadiationBetaElem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = A15JsonSensorsRadiationBetaElem(plain)
	return nil
}

type A15JsonSensorsRadiationBetaGammaElem struct {
	// The conversion from the <em>cpm</em> unit to another unit hardly depends on
	// your tube type. See the description of the value field to see how to use the
	// conversion factor. <strong>Note:</strong> only trust your manufacturer if it
	// comes to the actual factor value. The internet seems <a rel="nofollow"
	// href="http://sapporohibaku.wordpress.com/2011/10/15/conversion-factor/"
	// target="_blank">full of wrong copy & pastes</a>, don't even trust your
	// neighbour hackerspace. If in doubt ask the tube manufacturer.
	ConversionFactor *float64 `json:"conversion_factor,omitempty" yaml:"conversion_factor,omitempty" mapstructure:"conversion_factor,omitempty"`

	// The dead time in µs. See the description of the value field to see how to use
	// the dead time.
	DeadTime *float64 `json:"dead_time,omitempty" yaml:"dead_time,omitempty" mapstructure:"dead_time,omitempty"`

	// An extra field that you can use to attach some additional information to this
	// sensor instance
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// The Unix timestamp (in seconds) when the sensor value changed most recently
	Lastchange *float64 `json:"lastchange,omitempty" yaml:"lastchange,omitempty" mapstructure:"lastchange,omitempty"`

	// The location of your sensor
	Location *string `json:"location,omitempty" yaml:"location,omitempty" mapstructure:"location,omitempty"`

	// This field is an additional field to give your sensor a name. This can be
	// useful if you have multiple sensors in the same location.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Choose the appropriate unit for your radiation sensor instance
	Unit A15JsonSensorsRadiationBetaGammaElemUnit `json:"unit" yaml:"unit" mapstructure:"unit"`

	// Observed counts per minute (ocpm) or actual radiation value. If the value are
	// the observed counts then the dead_time and conversion_factor fields must be
	// defined as well. CPM formula: <div>cpm = ocpm ( 1 + 1 / (1 - ocpm x dead_time)
	// )</div> Conversion formula: <div>µSv/h = cpm x conversion_factor</div>
	Value float64 `json:"value" yaml:"value" mapstructure:"value"`
}

type A15JsonSensorsRadiationBetaGammaElemUnit string

const A15JsonSensorsRadiationBetaGammaElemUnitCpm A15JsonSensorsRadiationBetaGammaElemUnit = "cpm"
const A15JsonSensorsRadiationBetaGammaElemUnitMSvA A15JsonSensorsRadiationBetaGammaElemUnit = "mSv/a"
const A15JsonSensorsRadiationBetaGammaElemUnitRH A15JsonSensorsRadiationBetaGammaElemUnit = "r/h"

var enumValues_A15JsonSensorsRadiationBetaGammaElemUnit = []interface{}{
	"cpm",
	"r/h",
	"µSv/h",
	"mSv/a",
	"µSv/a",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15JsonSensorsRadiationBetaGammaElemUnit) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_A15JsonSensorsRadiationBetaGammaElemUnit {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_A15JsonSensorsRadiationBetaGammaElemUnit, v)
	}
	*j = A15JsonSensorsRadiationBetaGammaElemUnit(v)
	return nil
}

const A15JsonSensorsRadiationBetaGammaElemUnitΜSvA A15JsonSensorsRadiationBetaGammaElemUnit = "µSv/a"
const A15JsonSensorsRadiationBetaGammaElemUnitΜSvH A15JsonSensorsRadiationBetaGammaElemUnit = "µSv/h"

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15JsonSensorsRadiationBetaGammaElem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["unit"]; raw != nil && !ok {
		return fmt.Errorf("field unit in A15JsonSensorsRadiationBetaGammaElem: required")
	}
	if _, ok := raw["value"]; raw != nil && !ok {
		return fmt.Errorf("field value in A15JsonSensorsRadiationBetaGammaElem: required")
	}
	type Plain A15JsonSensorsRadiationBetaGammaElem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = A15JsonSensorsRadiationBetaGammaElem(plain)
	return nil
}

type A15JsonSensorsRadiationGammaElem struct {
	// The conversion from the <em>cpm</em> unit to another unit hardly depends on
	// your tube type. See the description of the value field to see how to use the
	// conversion factor. <strong>Note:</strong> only trust your manufacturer if it
	// comes to the actual factor value. The internet seems <a rel="nofollow"
	// href="http://sapporohibaku.wordpress.com/2011/10/15/conversion-factor/"
	// target="_blank">full of wrong copy & pastes</a>, don't even trust your
	// neighbour hackerspace. If in doubt ask the tube manufacturer.
	ConversionFactor *float64 `json:"conversion_factor,omitempty" yaml:"conversion_factor,omitempty" mapstructure:"conversion_factor,omitempty"`

	// The dead time in µs. See the description of the value field to see how to use
	// the dead time.
	DeadTime *float64 `json:"dead_time,omitempty" yaml:"dead_time,omitempty" mapstructure:"dead_time,omitempty"`

	// An extra field that you can use to attach some additional information to this
	// sensor instance
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// The Unix timestamp (in seconds) when the sensor value changed most recently
	Lastchange *float64 `json:"lastchange,omitempty" yaml:"lastchange,omitempty" mapstructure:"lastchange,omitempty"`

	// The location of your sensor
	Location *string `json:"location,omitempty" yaml:"location,omitempty" mapstructure:"location,omitempty"`

	// This field is an additional field to give your sensor a name. This can be
	// useful if you have multiple sensors in the same location.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Choose the appropriate unit for your radiation sensor instance
	Unit A15JsonSensorsRadiationGammaElemUnit `json:"unit" yaml:"unit" mapstructure:"unit"`

	// Observed counts per minute (ocpm) or actual radiation value. If the value are
	// the observed counts then the dead_time and conversion_factor fields must be
	// defined as well. CPM formula: <div>cpm = ocpm ( 1 + 1 / (1 - ocpm x dead_time)
	// )</div> Conversion formula: <div>µSv/h = cpm x conversion_factor</div>
	Value float64 `json:"value" yaml:"value" mapstructure:"value"`
}

type A15JsonSensorsRadiationGammaElemUnit string

const A15JsonSensorsRadiationGammaElemUnitCpm A15JsonSensorsRadiationGammaElemUnit = "cpm"
const A15JsonSensorsRadiationGammaElemUnitMSvA A15JsonSensorsRadiationGammaElemUnit = "mSv/a"
const A15JsonSensorsRadiationGammaElemUnitRH A15JsonSensorsRadiationGammaElemUnit = "r/h"

var enumValues_A15JsonSensorsRadiationGammaElemUnit = []interface{}{
	"cpm",
	"r/h",
	"µSv/h",
	"mSv/a",
	"µSv/a",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15JsonSensorsRadiationGammaElemUnit) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_A15JsonSensorsRadiationGammaElemUnit {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_A15JsonSensorsRadiationGammaElemUnit, v)
	}
	*j = A15JsonSensorsRadiationGammaElemUnit(v)
	return nil
}

const A15JsonSensorsRadiationGammaElemUnitΜSvA A15JsonSensorsRadiationGammaElemUnit = "µSv/a"
const A15JsonSensorsRadiationGammaElemUnitΜSvH A15JsonSensorsRadiationGammaElemUnit = "µSv/h"

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15JsonSensorsRadiationGammaElem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["unit"]; raw != nil && !ok {
		return fmt.Errorf("field unit in A15JsonSensorsRadiationGammaElem: required")
	}
	if _, ok := raw["value"]; raw != nil && !ok {
		return fmt.Errorf("field value in A15JsonSensorsRadiationGammaElem: required")
	}
	type Plain A15JsonSensorsRadiationGammaElem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = A15JsonSensorsRadiationGammaElem(plain)
	return nil
}

type A15JsonSensorsTemperatureElem struct {
	// An extra field that you can use to attach some additional information to this
	// sensor instance
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// The Unix timestamp (in seconds) when the sensor value changed most recently
	Lastchange *float64 `json:"lastchange,omitempty" yaml:"lastchange,omitempty" mapstructure:"lastchange,omitempty"`

	// The location of your sensor
	Location string `json:"location" yaml:"location" mapstructure:"location"`

	// This field is an additional field to give your sensor a name. This can be
	// useful if you have multiple sensors in the same location.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// The unit of the sensor value.
	Unit A15JsonSensorsTemperatureElemUnit `json:"unit" yaml:"unit" mapstructure:"unit"`

	// The sensor value
	Value float64 `json:"value" yaml:"value" mapstructure:"value"`
}

type A15JsonSensorsTemperatureElemUnit string

const A15JsonSensorsTemperatureElemUnitC A15JsonSensorsTemperatureElemUnit = "°C"
const A15JsonSensorsTemperatureElemUnitDe A15JsonSensorsTemperatureElemUnit = "°De"
const A15JsonSensorsTemperatureElemUnitF A15JsonSensorsTemperatureElemUnit = "°F"
const A15JsonSensorsTemperatureElemUnitK A15JsonSensorsTemperatureElemUnit = "K"
const A15JsonSensorsTemperatureElemUnitN A15JsonSensorsTemperatureElemUnit = "°N"
const A15JsonSensorsTemperatureElemUnitR A15JsonSensorsTemperatureElemUnit = "°R"
const A15JsonSensorsTemperatureElemUnitRé A15JsonSensorsTemperatureElemUnit = "°Ré"
const A15JsonSensorsTemperatureElemUnitRø A15JsonSensorsTemperatureElemUnit = "°Rø"

var enumValues_A15JsonSensorsTemperatureElemUnit = []interface{}{
	"°C",
	"°F",
	"K",
	"°De",
	"°N",
	"°R",
	"°Ré",
	"°Rø",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15JsonSensorsTemperatureElemUnit) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_A15JsonSensorsTemperatureElemUnit {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_A15JsonSensorsTemperatureElemUnit, v)
	}
	*j = A15JsonSensorsTemperatureElemUnit(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15JsonSensorsTemperatureElem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["location"]; raw != nil && !ok {
		return fmt.Errorf("field location in A15JsonSensorsTemperatureElem: required")
	}
	if _, ok := raw["unit"]; raw != nil && !ok {
		return fmt.Errorf("field unit in A15JsonSensorsTemperatureElem: required")
	}
	if _, ok := raw["value"]; raw != nil && !ok {
		return fmt.Errorf("field value in A15JsonSensorsTemperatureElem: required")
	}
	type Plain A15JsonSensorsTemperatureElem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = A15JsonSensorsTemperatureElem(plain)
	return nil
}

type A15JsonSensorsTotalMemberCountElem struct {
	// An extra field that you can use to attach some additional information to this
	// sensor instance
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// The Unix timestamp (in seconds) when the sensor value changed most recently
	Lastchange *float64 `json:"lastchange,omitempty" yaml:"lastchange,omitempty" mapstructure:"lastchange,omitempty"`

	// Specify the location if your hackerspace has different departments (for
	// whatever reason). This field is for one department. Every department should
	// have its own sensor instance.
	Location *string `json:"location,omitempty" yaml:"location,omitempty" mapstructure:"location,omitempty"`

	// You can use this field to specify if this sensor instance counts active or
	// inactive members.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// The amount of your space members.
	Value float64 `json:"value" yaml:"value" mapstructure:"value"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15JsonSensorsTotalMemberCountElem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["value"]; raw != nil && !ok {
		return fmt.Errorf("field value in A15JsonSensorsTotalMemberCountElem: required")
	}
	type Plain A15JsonSensorsTotalMemberCountElem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = A15JsonSensorsTotalMemberCountElem(plain)
	return nil
}

type A15JsonSensorsWindElem struct {
	// An extra field that you can use to attach some additional information to this
	// sensor instance
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// The Unix timestamp (in seconds) when the sensor value changed most recently
	Lastchange *float64 `json:"lastchange,omitempty" yaml:"lastchange,omitempty" mapstructure:"lastchange,omitempty"`

	// The location of your sensor
	Location string `json:"location" yaml:"location" mapstructure:"location"`

	// This field is an additional field to give your sensor a name. This can be
	// useful if you have multiple sensors in the same location.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Properties corresponds to the JSON schema field "properties".
	Properties A15JsonSensorsWindElemProperties `json:"properties" yaml:"properties" mapstructure:"properties"`
}

type A15JsonSensorsWindElemProperties struct {
	// The wind direction in degrees
	Direction A15JsonSensorsWindElemPropertiesDirection `json:"direction" yaml:"direction" mapstructure:"direction"`

	// Height above mean sea level
	Elevation A15JsonSensorsWindElemPropertiesElevation `json:"elevation" yaml:"elevation" mapstructure:"elevation"`

	// Gust corresponds to the JSON schema field "gust".
	Gust A15JsonSensorsWindElemPropertiesGust `json:"gust" yaml:"gust" mapstructure:"gust"`

	// Speed corresponds to the JSON schema field "speed".
	Speed A15JsonSensorsWindElemPropertiesSpeed `json:"speed" yaml:"speed" mapstructure:"speed"`
}

// The wind direction in degrees
type A15JsonSensorsWindElemPropertiesDirection struct {
	// The direction unit
	Unit A15JsonSensorsWindElemPropertiesDirectionUnit `json:"unit" yaml:"unit" mapstructure:"unit"`

	// The sensor value
	Value float64 `json:"value" yaml:"value" mapstructure:"value"`
}

type A15JsonSensorsWindElemPropertiesDirectionUnit string

const A15JsonSensorsWindElemPropertiesDirectionUnitUndefined A15JsonSensorsWindElemPropertiesDirectionUnit = "°"

var enumValues_A15JsonSensorsWindElemPropertiesDirectionUnit = []interface{}{
	"°",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15JsonSensorsWindElemPropertiesDirectionUnit) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_A15JsonSensorsWindElemPropertiesDirectionUnit {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_A15JsonSensorsWindElemPropertiesDirectionUnit, v)
	}
	*j = A15JsonSensorsWindElemPropertiesDirectionUnit(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15JsonSensorsWindElemPropertiesDirection) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["unit"]; raw != nil && !ok {
		return fmt.Errorf("field unit in A15JsonSensorsWindElemPropertiesDirection: required")
	}
	if _, ok := raw["value"]; raw != nil && !ok {
		return fmt.Errorf("field value in A15JsonSensorsWindElemPropertiesDirection: required")
	}
	type Plain A15JsonSensorsWindElemPropertiesDirection
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = A15JsonSensorsWindElemPropertiesDirection(plain)
	return nil
}

// Height above mean sea level
type A15JsonSensorsWindElemPropertiesElevation struct {
	// The elevation unit
	Unit A15JsonSensorsWindElemPropertiesElevationUnit `json:"unit" yaml:"unit" mapstructure:"unit"`

	// The sensor value
	Value float64 `json:"value" yaml:"value" mapstructure:"value"`
}

type A15JsonSensorsWindElemPropertiesElevationUnit string

const A15JsonSensorsWindElemPropertiesElevationUnitM A15JsonSensorsWindElemPropertiesElevationUnit = "m"

var enumValues_A15JsonSensorsWindElemPropertiesElevationUnit = []interface{}{
	"m",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15JsonSensorsWindElemPropertiesElevationUnit) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_A15JsonSensorsWindElemPropertiesElevationUnit {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_A15JsonSensorsWindElemPropertiesElevationUnit, v)
	}
	*j = A15JsonSensorsWindElemPropertiesElevationUnit(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15JsonSensorsWindElemPropertiesElevation) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["unit"]; raw != nil && !ok {
		return fmt.Errorf("field unit in A15JsonSensorsWindElemPropertiesElevation: required")
	}
	if _, ok := raw["value"]; raw != nil && !ok {
		return fmt.Errorf("field value in A15JsonSensorsWindElemPropertiesElevation: required")
	}
	type Plain A15JsonSensorsWindElemPropertiesElevation
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = A15JsonSensorsWindElemPropertiesElevation(plain)
	return nil
}

type A15JsonSensorsWindElemPropertiesGust struct {
	// The gust speed unit
	Unit A15JsonSensorsWindElemPropertiesGustUnit `json:"unit" yaml:"unit" mapstructure:"unit"`

	// The sensor value
	Value float64 `json:"value" yaml:"value" mapstructure:"value"`
}

type A15JsonSensorsWindElemPropertiesGustUnit string

const A15JsonSensorsWindElemPropertiesGustUnitKmH A15JsonSensorsWindElemPropertiesGustUnit = "km/h"
const A15JsonSensorsWindElemPropertiesGustUnitKn A15JsonSensorsWindElemPropertiesGustUnit = "kn"
const A15JsonSensorsWindElemPropertiesGustUnitMS A15JsonSensorsWindElemPropertiesGustUnit = "m/s"

var enumValues_A15JsonSensorsWindElemPropertiesGustUnit = []interface{}{
	"m/s",
	"km/h",
	"kn",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15JsonSensorsWindElemPropertiesGustUnit) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_A15JsonSensorsWindElemPropertiesGustUnit {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_A15JsonSensorsWindElemPropertiesGustUnit, v)
	}
	*j = A15JsonSensorsWindElemPropertiesGustUnit(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15JsonSensorsWindElemPropertiesGust) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["unit"]; raw != nil && !ok {
		return fmt.Errorf("field unit in A15JsonSensorsWindElemPropertiesGust: required")
	}
	if _, ok := raw["value"]; raw != nil && !ok {
		return fmt.Errorf("field value in A15JsonSensorsWindElemPropertiesGust: required")
	}
	type Plain A15JsonSensorsWindElemPropertiesGust
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = A15JsonSensorsWindElemPropertiesGust(plain)
	return nil
}

type A15JsonSensorsWindElemPropertiesSpeed struct {
	// The wind speed unit
	Unit A15JsonSensorsWindElemPropertiesSpeedUnit `json:"unit" yaml:"unit" mapstructure:"unit"`

	// The sensor value
	Value float64 `json:"value" yaml:"value" mapstructure:"value"`
}

type A15JsonSensorsWindElemPropertiesSpeedUnit string

const A15JsonSensorsWindElemPropertiesSpeedUnitKmH A15JsonSensorsWindElemPropertiesSpeedUnit = "km/h"
const A15JsonSensorsWindElemPropertiesSpeedUnitKn A15JsonSensorsWindElemPropertiesSpeedUnit = "kn"
const A15JsonSensorsWindElemPropertiesSpeedUnitMS A15JsonSensorsWindElemPropertiesSpeedUnit = "m/s"

var enumValues_A15JsonSensorsWindElemPropertiesSpeedUnit = []interface{}{
	"m/s",
	"km/h",
	"kn",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15JsonSensorsWindElemPropertiesSpeedUnit) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_A15JsonSensorsWindElemPropertiesSpeedUnit {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_A15JsonSensorsWindElemPropertiesSpeedUnit, v)
	}
	*j = A15JsonSensorsWindElemPropertiesSpeedUnit(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15JsonSensorsWindElemPropertiesSpeed) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["unit"]; raw != nil && !ok {
		return fmt.Errorf("field unit in A15JsonSensorsWindElemPropertiesSpeed: required")
	}
	if _, ok := raw["value"]; raw != nil && !ok {
		return fmt.Errorf("field value in A15JsonSensorsWindElemPropertiesSpeed: required")
	}
	type Plain A15JsonSensorsWindElemPropertiesSpeed
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = A15JsonSensorsWindElemPropertiesSpeed(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15JsonSensorsWindElemProperties) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["direction"]; raw != nil && !ok {
		return fmt.Errorf("field direction in A15JsonSensorsWindElemProperties: required")
	}
	if _, ok := raw["elevation"]; raw != nil && !ok {
		return fmt.Errorf("field elevation in A15JsonSensorsWindElemProperties: required")
	}
	if _, ok := raw["gust"]; raw != nil && !ok {
		return fmt.Errorf("field gust in A15JsonSensorsWindElemProperties: required")
	}
	if _, ok := raw["speed"]; raw != nil && !ok {
		return fmt.Errorf("field speed in A15JsonSensorsWindElemProperties: required")
	}
	type Plain A15JsonSensorsWindElemProperties
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = A15JsonSensorsWindElemProperties(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15JsonSensorsWindElem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["location"]; raw != nil && !ok {
		return fmt.Errorf("field location in A15JsonSensorsWindElem: required")
	}
	if _, ok := raw["properties"]; raw != nil && !ok {
		return fmt.Errorf("field properties in A15JsonSensorsWindElem: required")
	}
	type Plain A15JsonSensorsWindElem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = A15JsonSensorsWindElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15JsonSensors) UnmarshalJSON(value []byte) error {
	type Plain A15JsonSensors
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.NetworkTraffic != nil && len(plain.NetworkTraffic) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "network_traffic", 1)
	}
	*j = A15JsonSensors(plain)
	return nil
}

// A flag indicating if the hackerspace uses SpaceFED, a federated login scheme so
// that visiting hackers can use the space WiFi with their home space credentials.
type A15JsonSpacefed struct {
	// See the <a target="_blank"
	// href="https://spacefed.net/index.php/Category:Howto/Spacenet">wiki</a>.
	Spacenet bool `json:"spacenet" yaml:"spacenet" mapstructure:"spacenet"`

	// See the <a target="_blank"
	// href="https://spacefed.net/index.php?title=Spacesaml">wiki</a>.
	Spacesaml bool `json:"spacesaml" yaml:"spacesaml" mapstructure:"spacesaml"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15JsonSpacefed) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["spacenet"]; raw != nil && !ok {
		return fmt.Errorf("field spacenet in A15JsonSpacefed: required")
	}
	if _, ok := raw["spacesaml"]; raw != nil && !ok {
		return fmt.Errorf("field spacesaml in A15JsonSpacefed: required")
	}
	type Plain A15JsonSpacefed
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = A15JsonSpacefed(plain)
	return nil
}

// A collection of status-related data: actual open/closed status, icons, last
// change timestamp etc.
type A15JsonState struct {
	// Icons that show the status graphically
	Icon *A15JsonStateIcon `json:"icon,omitempty" yaml:"icon,omitempty" mapstructure:"icon,omitempty"`

	// The Unix timestamp (in seconds) when the space status changed most recently
	Lastchange *float64 `json:"lastchange,omitempty" yaml:"lastchange,omitempty" mapstructure:"lastchange,omitempty"`

	// An additional free-form string, could be something like <samp>'open for
	// public'</samp>, <samp>'members only'</samp> or whatever you want it to be
	Message *string `json:"message,omitempty" yaml:"message,omitempty" mapstructure:"message,omitempty"`

	// A flag which indicates whether the space is currently open or closed. The state
	// 'undefined' can be achieved by omitting this field. A missing 'open' property
	// carries the semantics of a temporary unavailability of the state, whereas the
	// absence of the 'state' property itself means the state is generally not
	// implemented for this space.
	Open *bool `json:"open,omitempty" yaml:"open,omitempty" mapstructure:"open,omitempty"`

	// The person who lastly changed the state e.g. opened or closed the space.
	TriggerPerson *string `json:"trigger_person,omitempty" yaml:"trigger_person,omitempty" mapstructure:"trigger_person,omitempty"`
}

// Icons that show the status graphically
type A15JsonStateIcon struct {
	// The URL to your customized space logo showing a closed space
	Closed string `json:"closed" yaml:"closed" mapstructure:"closed"`

	// The URL to your customized space logo showing an open space
	Open string `json:"open" yaml:"open" mapstructure:"open"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15JsonStateIcon) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["closed"]; raw != nil && !ok {
		return fmt.Errorf("field closed in A15JsonStateIcon: required")
	}
	if _, ok := raw["open"]; raw != nil && !ok {
		return fmt.Errorf("field open in A15JsonStateIcon: required")
	}
	type Plain A15JsonStateIcon
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = A15JsonStateIcon(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *A15Json) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["api_compatibility"]; raw != nil && !ok {
		return fmt.Errorf("field api_compatibility in A15Json: required")
	}
	if _, ok := raw["contact"]; raw != nil && !ok {
		return fmt.Errorf("field contact in A15Json: required")
	}
	if _, ok := raw["logo"]; raw != nil && !ok {
		return fmt.Errorf("field logo in A15Json: required")
	}
	if _, ok := raw["space"]; raw != nil && !ok {
		return fmt.Errorf("field space in A15Json: required")
	}
	if _, ok := raw["url"]; raw != nil && !ok {
		return fmt.Errorf("field url in A15Json: required")
	}
	type Plain A15Json
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.Cam != nil && len(plain.Cam) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "cam", 1)
	}
	*j = A15Json(plain)
	return nil
}
